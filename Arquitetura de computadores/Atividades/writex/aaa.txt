
# burocracias 
.code16 			    
.text 				    
.globl _start

# https://4beginner.com/8086-Assembly-Language-INT-10h-Video-Interrupt
# https://www.stanislavs.org/helppc/int_10.html

# ponto de entrada do programa
_start: 

# cl recebe 80 para ser usado no loop 
# (quantidade de caracteres numa linha)
movb $80, %cl
print_row:
    # registrador al recebe 'x'
    movb $'x' , %al
    # registrador ah recebe 0x0e 
    # modo tele type, eu 

    # quando voce usa a interrupção 0x10 da bios com o serviço 0x0E o sistema exibe um caractere na tela 
    # O valor 0x0E em  específico diz à BIOS que você quer usar o modo teletype,
    # que simplesmente imprime um caractere na tela.

    # Neste ponto, você está configurando o registrador AHcom o valor 0x0E,
    # que indica que o serviço que você quer usar é o modo teletype (imprimir um caractere na tela).

    movb $0x0e, %ah		

    # interrupção de vídeo (printa na tela)
    # A interrupção int $0x10 é usada para chamar o BIOS para manipulação de vídeo. 
    # Como AHbfoi configurado para 0x0E, o sistema entende que deve imprimir o caractere ALna tela.

    # A interrupção 0x10é chamada, que é a interrupção de vídeo . Ela verifica o serviço configurado em AH(neste caso, o serviço 0x0Eque imprime um caractere) e executa o serviço, imprimindo o caractere que está ALna tela.
    int  $0x10


    # coloco o valor do loop que eu quero em CL
    # a cada rodada decrementa o valor em cl
    decb %cl
    # se cl for diferente de 0, volta pro print_row
    # jnz verifica s
    
    jnz print_row





# cl recebe 23 pra ser usado no loop 
# (25 linhas - 1 do começo e 1 do final)
movb $23, %cl
loop_23:
    # registrador al recebe 'x'
    movb $'x' , %al
    # corzinha
    movb $0x0e, %ah		
    # printa
    int  $0x10

    # registrador ch recebe 78 (quantidade de espaços entre o x do começo e o x do final da linha)
    movb $78, %ch
    loop_78:
        # registrador al recebe ' '
        movb $' ' , %al
        # corzinha
        movb $0x0e, %ah		
        # printa o espaço
        int  $0x10
        # decrementa o ch
        decb %ch
        # se ch for diferente de 0, volta pro loop_78
        jnz loop_78

    # printa o x no final da linha
    movb $'x' , %al
    movb $0x0e, %ah		
    int  $0x10

    # decrementa o cl
    decb %cl
    # se cl for diferente de 0, volta pro loop_23
    jnz loop_23

# cl recebe 79 para ser usado no loop 
#(1 caractere a menos para ele não pular sozinho pra próxima linha e a primeira ficar fora da tela)
movb $79, %cl

# printar a linha de x do final
print_row2:
    movb $'x' , %al
    movb $0x0e, %ah		
    int  $0x10
    decb %cl
    jnz print_row2



# loop para manter o processador em estado de halt
loop_final:
    hlt
    jmp loop_final

# move o contador da posição atual no código (representado pelo .) para o byte 510
. = _start + 510

# assinatura de boot MBR
# pro programa ser reconhecido como boot MBR, é preciso que os bytes 510 e 511 tenham os valores 0x55 e 0xaa
.byte 0x55		        
.byte 0xaa		        
